#!/usr/bin/env python3
"""
WASM Test Generator

This script automatically generates WASM test functions from existing tests
that use the run_with_both_backends pattern. It follows the DRY principle
by reusing the existing test logic.
"""

import os
import re
import glob

def extract_test_functions(test_file):
    """Extract test functions that use run_with_both_backends from a test file."""
    with open(test_file, 'r') as f:
        content = f.read()
    
    # First find all test functions - more flexible pattern
    test_pattern = r'#\[test\]\s*\nfn\s+(\w+)\s*\([^)]*\)\s*->\s*(Result<\(\)(?:,\s*tegdb::Error)?>)\s*\{([^}]+)\}'
    test_matches = re.finditer(test_pattern, content, re.DOTALL)
    
    tests = []
    for test_match in test_matches:
        test_name = test_match.group(1)
        test_body = test_match.group(2)
        
        # Check if this test uses run_with_both_backends
        rwb_pattern = r'run_with_both_backends\("([^"]+)",\s*\|([^|]+)\|\s*\{([^}]+)\}\)'
        rwb_match = re.search(rwb_pattern, test_body, re.DOTALL)
        
        if rwb_match:
            test_display_name = rwb_match.group(1)
            db_path_param = rwb_match.group(2)
            inner_body = rwb_match.group(3)
            
            tests.append({
                'name': test_name,
                'display_name': test_display_name,
                'db_path_param': db_path_param,
                'body': inner_body.strip()
            })
    
    return tests

def generate_wasm_test_function(test):
    """Generate a WASM test function from a test definition."""
    wasm_test_name = f"wasm_{test['name']}"
    
    return f"""#[cfg(target_arch = "wasm32")]
#[wasm_bindgen_test]
fn {wasm_test_name}() -> Result<()> {{
    run_with_both_backends("{test['display_name']}", |{test['db_path_param']}| {{
{test['body']}
    }})
}}"""

def generate_wasm_tests_file():
    """Generate the complete WASM tests file."""
    # Find all test files
    test_files = glob.glob('tests/*.rs')
    
    all_tests = []
    for test_file in test_files:
        if test_file.endswith('test_helpers.rs') or test_file.endswith('wasm_tests.rs'):
            continue  # Skip helper files and existing WASM tests
        
        tests = extract_test_functions(test_file)
        all_tests.extend(tests)
    
    # Generate the WASM tests file
    wasm_tests_content = f'''//! WASM Integration Tests
//! 
//! This file is automatically generated by generate_wasm_tests.py
//! It contains WASM test functions for all tests that use run_with_both_backends.
//! 
//! Total tests: {len(all_tests)}

#[cfg(target_arch = "wasm32")]
use wasm_bindgen_test::*;

#[cfg(target_arch = "wasm32")]
use tegdb::{{Database, Result, SqlValue}};

#[cfg(target_arch = "wasm32")]
wasm_bindgen_test_configure!(run_in_node);

#[cfg(target_arch = "wasm32")]
mod test_helpers;
#[cfg(target_arch = "wasm32")]
use test_helpers::run_with_both_backends;

// Generated WASM test functions
'''
    
    for test in all_tests:
        wasm_tests_content += generate_wasm_test_function(test) + "\n\n"
    
    # Write the file
    with open('tests/wasm_integration_tests.rs', 'w') as f:
        f.write(wasm_tests_content)
    
    print(f"Generated {len(all_tests)} WASM test functions in tests/wasm_integration_tests.rs")
    return len(all_tests)

if __name__ == '__main__':
    count = generate_wasm_tests_file()
    print(f"Successfully generated {count} WASM test functions!")
    print("Now you can run: wasm-pack test --node") 