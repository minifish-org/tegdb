#!/usr/bin/env python3
"""
WASM Test Generator

This script automatically generates WASM test functions from existing tests
that use the run_with_both_backends pattern. It follows the DRY principle
by reusing the existing test logic.
"""

import os
import re
import glob
import sys

def extract_test_functions(test_file):
    """Extract test functions that use run_with_both_backends from a test file."""
    with open(test_file, 'r') as f:
        content = f.read()
    
    # More flexible pattern to find test functions
    # This handles multi-line function signatures and bodies
    test_pattern = r'#\[test\]\s*\nfn\s+(\w+)\s*\([^)]*\)\s*->\s*Result<\(\)[^>]*>\s*\{'
    test_matches = list(re.finditer(test_pattern, content, re.DOTALL))
    
    tests = []
    for i, test_match in enumerate(test_matches):
        test_name = test_match.group(1)
        start_pos = test_match.end()
        
        # Find the end of this function by matching braces
        brace_count = 1
        end_pos = start_pos
        for j, char in enumerate(content[start_pos:], start_pos):
            if char == '{':
                brace_count += 1
            elif char == '}':
                brace_count -= 1
                if brace_count == 0:
                    end_pos = j + 1
                    break
        
        test_body = content[start_pos:end_pos]
        
        # Check if this test uses run_with_both_backends
        rwb_pattern = r'run_with_both_backends\("([^"]+)",\s*\|([^|]+)\|\s*\{'
        rwb_match = re.search(rwb_pattern, test_body, re.DOTALL)
        
        if rwb_match:
            test_display_name = rwb_match.group(1)
            db_path_param = rwb_match.group(2).strip()
            
            # Find the inner body of run_with_both_backends
            rwb_start = rwb_match.end()
            rwb_brace_count = 1
            rwb_end = rwb_start
            for j, char in enumerate(test_body[rwb_start:], rwb_start):
                if char == '{':
                    rwb_brace_count += 1
                elif char == '}':
                    rwb_brace_count -= 1
                    if rwb_brace_count == 0:
                        rwb_end = j
                        break
            
            inner_body = test_body[rwb_start:rwb_end].strip()
            
            tests.append({
                'name': test_name,
                'display_name': test_display_name,
                'db_path_param': db_path_param,
                'body': inner_body
            })
    
    return tests

def generate_wasm_test_function(test):
    """Generate a WASM test function from a test definition."""
    wasm_test_name = f"wasm_{test['name']}"
    
    return f"""#[cfg(target_arch = "wasm32")]
#[wasm_bindgen_test]
fn {wasm_test_name}() -> Result<()> {{
    run_with_both_backends("{test['display_name']}", |{test['db_path_param']}| {{
{test['body']}
    }})
}}"""

def generate_wasm_tests_file():
    """Generate the complete WASM tests file."""
    # Find all test files
    test_files = glob.glob('tests/*.rs')
    
    all_tests = []
    for test_file in test_files:
        if test_file.endswith('test_helpers.rs') or test_file.endswith('wasm_tests.rs') or test_file.endswith('wasm_integration_tests.rs'):
            continue  # Skip helper files and existing WASM tests
        
        tests = extract_test_functions(test_file)
        if tests:
            print(f"Found {len(tests)} tests in {test_file}")
        all_tests.extend(tests)
    
    # Generate the WASM tests file
    wasm_tests_content = f'''//! WASM Integration Tests
//! 
//! This file is automatically generated by generate_wasm_tests.py
//! It contains WASM test functions for all tests that use run_with_both_backends.
//! 
//! Total tests: {len(all_tests)}

#[cfg(target_arch = "wasm32")]
use wasm_bindgen_test::*;

#[cfg(target_arch = "wasm32")]
use tegdb::{{Database, Result, SqlValue}};

#[cfg(target_arch = "wasm32")]
wasm_bindgen_test_configure!(run_in_node);

#[cfg(target_arch = "wasm32")]
mod test_helpers;
#[cfg(target_arch = "wasm32")]
use crate::test_helpers::run_with_both_backends;

// Generated WASM test functions
'''
    
    for test in all_tests:
        wasm_tests_content += generate_wasm_test_function(test) + "\n\n"
    
    # Write the file
    with open('tests/wasm_integration_tests.rs', 'w') as f:
        f.write(wasm_tests_content)
    
    print(f"Generated {len(all_tests)} WASM test functions in tests/wasm_integration_tests.rs")
    return len(all_tests)

if __name__ == '__main__':
    debug_mode = '--debug' in sys.argv
    if debug_mode:
        print("Debug mode enabled")
    
    count = generate_wasm_tests_file()
    print(f"Successfully generated {count} WASM test functions!")
    print("Now you can run: wasm-pack test --node") 