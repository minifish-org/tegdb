//! Query planner and optimizer for TegDB
//!
//! This module provides a query planner that takes parsed SQL statements and generates
//! optimized execution plans. The planner sits between the parser and executor,
//! similar to PostgreSQL and SQLite architectures.

use crate::parser::{
    SqlValue, Condition, Statement, SelectStatement, InsertStatement, UpdateStatement,
    DeleteStatement, CreateTableStatement, DropTableStatement, ComparisonOperator,
};
use crate::executor::{ColumnInfo, TableSchema};
use crate::Result;
use std::collections::HashMap;
use std::rc::Rc;

/// A query execution plan generated by the planner
#[derive(Debug, Clone)]
pub enum ExecutionPlan {
    /// Direct primary key lookup (most efficient)
    PrimaryKeyLookup {
        table: String,
        pk_values: HashMap<String, SqlValue>,
        selected_columns: Vec<String>,
        additional_filter: Option<Condition>,
    },
    /// Full table scan with optimizations
    TableScan {
        table: String,
        selected_columns: Vec<String>,
        filter: Option<Condition>,
        limit: Option<u64>,
        early_termination: bool,
    },
    /// Insert operation plan
    Insert {
        table: String,
        rows: Vec<HashMap<String, SqlValue>>,
        conflict_resolution: ConflictResolution,
    },
    /// Update operation plan
    Update {
        table: String,
        assignments: Vec<Assignment>,
        scan_plan: Box<ExecutionPlan>,
    },
    /// Delete operation plan
    Delete {
        table: String,
        scan_plan: Box<ExecutionPlan>,
    },
    /// DDL operations
    CreateTable {
        table: String,
        schema: TableSchema,
    },
    DropTable {
        table: String,
        if_exists: bool,
    },
    /// Transaction control
    Begin,
    Commit,
    Rollback,
}

/// Index condition for index scans
#[derive(Debug, Clone)]
pub struct IndexCondition {
    pub column: String,
    pub operator: ComparisonOperator,
    pub value: SqlValue,
}

/// Assignment for update operations
#[derive(Debug, Clone)]
pub struct Assignment {
    pub column: String,
    pub value: crate::parser::Expression,
}

/// Conflict resolution strategy for inserts
#[derive(Debug, Clone)]
pub enum ConflictResolution {
    Error,   // Fail on constraint violation
    Ignore,  // Skip conflicting rows
    Replace, // Replace existing rows
}

/// Cost estimation for different plan types
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Cost {
    pub io_cost: f64,     // Estimated I/O operations
    pub cpu_cost: f64,    // Estimated CPU operations
    pub memory_cost: f64, // Estimated memory usage
}

impl Cost {
    pub fn new(io_cost: f64, cpu_cost: f64, memory_cost: f64) -> Self {
        Self {
            io_cost,
            cpu_cost,
            memory_cost,
        }
    }

    pub fn total(&self) -> f64 {
        self.io_cost + self.cpu_cost + self.memory_cost
    }

    pub fn zero() -> Self {
        Self::new(0.0, 0.0, 0.0)
    }
}

/// Query planner that generates optimized execution plans
pub struct QueryPlanner {
    /// Table schemas for optimization decisions
    table_schemas: HashMap<String, Rc<TableSchema>>,
    /// Table statistics for cost estimation
    table_stats: HashMap<String, TableStatistics>,
    /// Configuration for optimization decisions
    config: PlannerConfig,
}

/// Statistics about tables for cost-based optimization
#[derive(Debug, Clone)]
pub struct TableStatistics {
    pub row_count: u64,
    pub avg_row_size: usize,
    pub column_stats: HashMap<String, ColumnStatistics>,
}

/// Statistics about individual columns
#[derive(Debug, Clone)]
pub struct ColumnStatistics {
    pub distinct_values: u64,
    pub null_ratio: f64,
    pub most_common_values: Vec<(SqlValue, f64)>, // value, frequency
}

/// Configuration for the query planner
#[derive(Debug, Clone)]
pub struct PlannerConfig {
    /// Cost weights for different operations
    pub seq_scan_cost: f64,
    pub index_scan_cost: f64,
    pub pk_lookup_cost: f64,
    pub cpu_tuple_cost: f64,
    pub memory_page_cost: f64,

    /// Optimization thresholds
    pub enable_pk_optimization: bool,
    pub enable_predicate_pushdown: bool,
    pub enable_limit_pushdown: bool,
    pub small_table_threshold: u64, // Rows below which we prefer table scan
}

impl Default for PlannerConfig {
    fn default() -> Self {
        Self {
            seq_scan_cost: 1.0,
            index_scan_cost: 0.1,
            pk_lookup_cost: 0.01,
            cpu_tuple_cost: 0.01,
            memory_page_cost: 1.0,
            enable_pk_optimization: true,
            enable_predicate_pushdown: true,
            enable_limit_pushdown: true,
            small_table_threshold: 1000,
        }
    }
}

impl QueryPlanner {
    /// Create a new query planner with table schemas
    pub fn new(table_schemas: HashMap<String, Rc<TableSchema>>) -> Self {
        Self {
            table_schemas,
            table_stats: HashMap::new(),
            config: PlannerConfig::default(),
        }
    }

    /// Create a planner with custom configuration
    pub fn with_config(table_schemas: HashMap<String, Rc<TableSchema>>, config: PlannerConfig) -> Self {
        Self {
            table_schemas,
            table_stats: HashMap::new(),
            config,
        }
    }

    /// Update table statistics for better cost estimation
    pub fn update_table_stats(&mut self, table: String, stats: TableStatistics) {
        self.table_stats.insert(table, stats);
    }

    /// Generate an optimized execution plan for a SQL statement
    pub fn plan(&self, statement: Statement) -> Result<ExecutionPlan> {
        match statement {
            Statement::Select(select) => self.plan_select(select),
            Statement::Insert(insert) => self.plan_insert(insert),
            Statement::Update(update) => self.plan_update(update),
            Statement::Delete(delete) => self.plan_delete(delete),
            Statement::CreateTable(create) => self.plan_create_table(create),
            Statement::DropTable(drop) => self.plan_drop_table(drop),
            Statement::Begin => Ok(ExecutionPlan::Begin),
            Statement::Commit => Ok(ExecutionPlan::Commit),
            Statement::Rollback => Ok(ExecutionPlan::Rollback),
        }
    }

    /// Plan SELECT statement with optimizations
    fn plan_select(&self, select: SelectStatement) -> Result<ExecutionPlan> {
        // Try primary key lookup first (most efficient)
        if let Some(pk_plan) = self.try_primary_key_lookup(&select)? {
            return Ok(pk_plan);
        }

        // Fall back to table scan with optimizations
        self.plan_table_scan(&select)
    }

    /// Try to create a primary key lookup plan
    fn try_primary_key_lookup(&self, select: &SelectStatement) -> Result<Option<ExecutionPlan>> {
        if !self.config.enable_pk_optimization {
            return Ok(None);
        }

        // Check if we have a WHERE clause that can be used for PK lookup
        if let Some(ref where_clause) = select.where_clause {
            if let Some(pk_values) =
                self.extract_pk_equality_conditions(&select.table, &where_clause.condition)?
            {
                // Check if we have all primary key columns
                let pk_columns = self.get_primary_key_columns(&select.table)?;
                if pk_values.len() == pk_columns.len() {
                    let additional_filter =
                        self.extract_non_pk_conditions(&select.table, &where_clause.condition)?;
                    let selected_columns =
                        self.normalize_selected_columns(&select.table, &select.columns)?;

                    return Ok(Some(ExecutionPlan::PrimaryKeyLookup {
                        table: select.table.clone(),
                        pk_values,
                        selected_columns,
                        additional_filter,
                    }));
                }
            }
        }

        Ok(None)
    }

    /// Plan table scan with optimizations
    fn plan_table_scan(&self, select: &SelectStatement) -> Result<ExecutionPlan> {
        let selected_columns = self.normalize_selected_columns(&select.table, &select.columns)?;
        let filter = select.where_clause.as_ref().map(|w| w.condition.clone());
        let early_termination = Self::is_simple_filter(filter.as_ref());

        Ok(ExecutionPlan::TableScan {
            table: select.table.clone(),
            selected_columns,
            filter,
            limit: select.limit,
            early_termination,
        })
    }

    /// Plan INSERT statement
    fn plan_insert(&self, insert: InsertStatement) -> Result<ExecutionPlan> {
        // Convert values to HashMap format for better performance
        let mut rows = Vec::with_capacity(insert.values.len());
        for value_row in insert.values {
            let mut row_data = HashMap::with_capacity(insert.columns.len());
            for (i, col_name) in insert.columns.iter().enumerate() {
                if let Some(value) = value_row.get(i) {
                    row_data.insert(col_name.clone(), value.clone());
                }
            }
            rows.push(row_data);
        }

        Ok(ExecutionPlan::Insert {
            table: insert.table,
            rows,
            conflict_resolution: ConflictResolution::Error,
        })
    }

    /// Plan UPDATE statement
    fn plan_update(&self, update: UpdateStatement) -> Result<ExecutionPlan> {
        // Convert assignments to planner format
        let assignments: Vec<Assignment> = update
            .assignments
            .into_iter()
            .map(|a| Assignment {
                column: a.column,
                value: a.value,
            })
            .collect();

        // Always expand ["*"] to all columns for scan plan
        let all_columns = self.normalize_selected_columns(&update.table, &["*".to_string()])?;

        // Create scan plan for the rows to update
        let scan_plan = if let Some(ref where_clause) = update.where_clause {
            // Try to optimize the scan based on WHERE clause
            if let Some(pk_values) =
                self.extract_pk_equality_conditions(&update.table, &where_clause.condition)?
            {
                let pk_columns = self.get_primary_key_columns(&update.table)?;
                if pk_values.len() == pk_columns.len() {
                    ExecutionPlan::PrimaryKeyLookup {
                        table: update.table.clone(),
                        pk_values,
                        selected_columns: all_columns.clone(),
                        additional_filter: None,
                    }
                } else {
                    ExecutionPlan::TableScan {
                        table: update.table.clone(),
                        selected_columns: all_columns.clone(),
                        filter: Some(where_clause.condition.clone()),
                        limit: None,
                        early_termination: false,
                    }
                }
            } else {
                ExecutionPlan::TableScan {
                    table: update.table.clone(),
                    selected_columns: all_columns.clone(),
                    filter: Some(where_clause.condition.clone()),
                    limit: None,
                    early_termination: false,
                }
            }
        } else {
            // No WHERE clause - scan all rows
            ExecutionPlan::TableScan {
                table: update.table.clone(),
                selected_columns: all_columns.clone(),
                filter: None,
                limit: None,
                early_termination: false,
            }
        };

        Ok(ExecutionPlan::Update {
            table: update.table,
            assignments,
            scan_plan: Box::new(scan_plan),
        })
    }

    /// Plan DELETE statement
    fn plan_delete(&self, delete: DeleteStatement) -> Result<ExecutionPlan> {
        // Always expand ["*"] to all columns for scan plan
        let all_columns = self.normalize_selected_columns(&delete.table, &["*".to_string()])?;

        // Create scan plan for the rows to delete
        let scan_plan = if let Some(ref where_clause) = delete.where_clause {
            // Try to optimize the scan based on WHERE clause
            if let Some(pk_values) =
                self.extract_pk_equality_conditions(&delete.table, &where_clause.condition)?
            {
                let pk_columns = self.get_primary_key_columns(&delete.table)?;
                if pk_values.len() == pk_columns.len() {
                    ExecutionPlan::PrimaryKeyLookup {
                        table: delete.table.clone(),
                        pk_values,
                        selected_columns: all_columns.clone(),
                        additional_filter: None,
                    }
                } else {
                    ExecutionPlan::TableScan {
                        table: delete.table.clone(),
                        selected_columns: all_columns.clone(),
                        filter: Some(where_clause.condition.clone()),
                        limit: None,
                        early_termination: false,
                    }
                }
            } else {
                ExecutionPlan::TableScan {
                    table: delete.table.clone(),
                    selected_columns: all_columns.clone(),
                    filter: Some(where_clause.condition.clone()),
                    limit: None,
                    early_termination: false,
                }
            }
        } else {
            // No WHERE clause - scan all rows
            ExecutionPlan::TableScan {
                table: delete.table.clone(),
                selected_columns: all_columns.clone(),
                filter: None,
                limit: None,
                early_termination: false,
            }
        };

        Ok(ExecutionPlan::Delete {
            table: delete.table,
            scan_plan: Box::new(scan_plan),
        })
    }

    /// Plan CREATE TABLE statement
    fn plan_create_table(&self, create: CreateTableStatement) -> Result<ExecutionPlan> {
        let schema = TableSchema {
            name: create.table.clone(),
            columns: create
                .columns
                .iter()
                .map(|col| ColumnInfo {
                    name: col.name.clone(),
                    data_type: col.data_type.clone(),
                    constraints: col.constraints.clone(),
                })
                .collect(),
        };

        Ok(ExecutionPlan::CreateTable {
            table: create.table,
            schema,
        })
    }

    /// Plan DROP TABLE statement
    fn plan_drop_table(&self, drop: DropTableStatement) -> Result<ExecutionPlan> {
        Ok(ExecutionPlan::DropTable {
            table: drop.table,
            if_exists: drop.if_exists,
        })
    }

    /// Extract primary key equality conditions from WHERE clause
    fn extract_pk_equality_conditions(
        &self,
        table_name: &str,
        condition: &Condition,
    ) -> Result<Option<HashMap<String, SqlValue>>> {
        let pk_columns = self.get_primary_key_columns(table_name)?;
        let mut pk_values = HashMap::new();

        Self::collect_pk_equality_values(condition, &pk_columns, &mut pk_values);

        // Check if we have values for ALL primary key columns
        if pk_values.len() == pk_columns.len() {
            Ok(Some(pk_values))
        } else {
            Ok(None)
        }
    }

    /// Recursively collect primary key equality values from conditions
    fn collect_pk_equality_values(
        condition: &Condition,
        pk_columns: &[String],
        pk_values: &mut HashMap<String, SqlValue>,
    ) {
        match condition {
            Condition::Comparison {
                left,
                operator,
                right,
            } => {
                if let ComparisonOperator::Equal = operator {
                    if pk_columns.contains(left) && !pk_values.contains_key(left) {
                        pk_values.insert(left.clone(), right.clone());
                    }
                }
            }
            Condition::And(left_cond, right_cond) => {
                Self::collect_pk_equality_values(left_cond, pk_columns, pk_values);
                Self::collect_pk_equality_values(right_cond, pk_columns, pk_values);
            }
            Condition::Or(_, _) => {
                // For OR conditions, we cannot optimize with PK lookup
            }
        }
    }

    /// Extract non-primary key conditions for additional filtering
    fn extract_non_pk_conditions(
        &self,
        table_name: &str,
        condition: &Condition,
    ) -> Result<Option<Condition>> {
        let pk_columns = self.get_primary_key_columns(table_name)?;

        fn filter_non_pk_conditions(
            condition: &Condition,
            pk_columns: &[String],
        ) -> Option<Condition> {
            match condition {
                Condition::Comparison {
                    left,
                    operator,
                    right: _,
                } => {
                    if pk_columns.contains(left) && matches!(operator, ComparisonOperator::Equal) {
                        None // This is a PK condition, filter it out
                    } else {
                        Some(condition.clone()) // Keep non-PK conditions
                    }
                }
                Condition::And(left, right) => {
                    let left_filtered = filter_non_pk_conditions(left, pk_columns);
                    let right_filtered = filter_non_pk_conditions(right, pk_columns);

                    match (left_filtered, right_filtered) {
                        (Some(l), Some(r)) => Some(Condition::And(Box::new(l), Box::new(r))),
                        (Some(l), None) => Some(l),
                        (None, Some(r)) => Some(r),
                        (None, None) => None,
                    }
                }
                Condition::Or(left, right) => {
                    let left_filtered = filter_non_pk_conditions(left, pk_columns);
                    let right_filtered = filter_non_pk_conditions(right, pk_columns);

                    match (left_filtered, right_filtered) {
                        (Some(l), Some(r)) => Some(Condition::Or(Box::new(l), Box::new(r))),
                        (Some(l), None) => Some(l),
                        (None, Some(r)) => Some(r),
                        (None, None) => None,
                    }
                }
            }
        }

        Ok(filter_non_pk_conditions(condition, &pk_columns))
    }

    /// Normalize selected columns: if ["*"] is given, expand to all columns from the schema
    fn normalize_selected_columns(
        &self,
        table_name: &str,
        columns: &[String],
    ) -> Result<Vec<String>> {
        if columns.len() == 1 && columns[0] == "*" {
            // Expand * to all columns from the schema
            if let Some(schema) = self.table_schemas.get(table_name) {
                Ok(schema.columns.iter().map(|c| c.name.clone()).collect())
            } else {
                Err(crate::Error::Other(format!(
                    "Table '{table_name}' not found for column expansion"
                )))
            }
        } else {
            Ok(columns.to_vec())
        }
    }

    /// Check if a filter is simple enough for early termination optimization
    fn is_simple_filter(filter: Option<&Condition>) -> bool {
        match filter {
            None => true,
            Some(Condition::Comparison { .. }) => true,
            Some(Condition::And(left, right)) => {
                Self::is_simple_filter(Some(left)) && Self::is_simple_filter(Some(right))
            }
            Some(Condition::Or(_, _)) => false, // OR conditions are more complex
        }
    }

    /// Get primary key columns for a table
    fn get_primary_key_columns(&self, table_name: &str) -> Result<Vec<String>> {
        if let Some(schema) = self.table_schemas.get(table_name) {
            let pk_columns: Vec<String> = schema
                .columns
                .iter()
                .filter(|col| {
                    col.constraints
                        .contains(&crate::parser::ColumnConstraint::PrimaryKey)
                })
                .map(|col| col.name.clone())
                .collect();
            Ok(pk_columns)
        } else {
            Err(crate::Error::Other(format!(
                "Table '{table_name}' not found"
            )))
        }
    }

    /// Update table schemas (called when DDL operations occur)
    pub fn update_table_schema(&mut self, table_name: String, schema: Rc<TableSchema>) {
        self.table_schemas.insert(table_name, schema);
    }

    /// Remove table schema (called when table is dropped)
    pub fn remove_table_schema(&mut self, table_name: &str) {
        self.table_schemas.remove(table_name);
        self.table_stats.remove(table_name);
    }

    /// Get current table schemas
    pub fn table_schemas(&self) -> &HashMap<String, Rc<TableSchema>> {
        &self.table_schemas
    }

    /// Get configuration
    pub fn config(&self) -> &PlannerConfig {
        &self.config
    }

    /// Update configuration
    pub fn update_config(&mut self, config: PlannerConfig) {
        self.config = config;
    }
}

/// Helper functions for plan analysis and debugging
impl ExecutionPlan {
    /// Get the main table involved in this plan
    pub fn primary_table(&self) -> Option<&str> {
        match self {
            ExecutionPlan::PrimaryKeyLookup { table, .. } => Some(table),
            ExecutionPlan::TableScan { table, .. } => Some(table),
            ExecutionPlan::Insert { table, .. } => Some(table),
            ExecutionPlan::Update { table, .. } => Some(table),
            ExecutionPlan::Delete { table, .. } => Some(table),
            ExecutionPlan::CreateTable { table, .. } => Some(table),
            ExecutionPlan::DropTable { table, .. } => Some(table),
            _ => None,
        }
    }

    /// Check if this plan involves a table scan
    pub fn requires_table_scan(&self) -> bool {
        match self {
            ExecutionPlan::TableScan { .. } => true,
            ExecutionPlan::Update { scan_plan, .. } => scan_plan.requires_table_scan(),
            ExecutionPlan::Delete { scan_plan, .. } => scan_plan.requires_table_scan(),
            _ => false,
        }
    }

    /// Get a human-readable description of the plan
    pub fn describe(&self) -> String {
        match self {
            ExecutionPlan::PrimaryKeyLookup {
                table, pk_values, ..
            } => {
                format!(
                    "Primary Key Lookup on {} (keys: {})",
                    table,
                    pk_values.len()
                )
            }
            ExecutionPlan::TableScan {
                table,
                early_termination,
                ..
            } => {
                if *early_termination {
                    format!("Table Scan on {table} (with early termination)")
                } else {
                    format!("Table Scan on {table}")
                }
            }
            ExecutionPlan::Insert { table, rows, .. } => {
                format!("Insert into {} ({} rows)", table, rows.len())
            }
            ExecutionPlan::Update {
                table, scan_plan, ..
            } => {
                format!("Update {} via {}", table, scan_plan.describe())
            }
            ExecutionPlan::Delete {
                table, scan_plan, ..
            } => {
                format!("Delete from {} via {}", table, scan_plan.describe())
            }
            ExecutionPlan::CreateTable { table, .. } => {
                format!("Create Table {table}")
            }
            ExecutionPlan::DropTable { table, .. } => {
                format!("Drop Table {table}")
            }
            ExecutionPlan::Begin => "Begin Transaction".to_string(),
            ExecutionPlan::Commit => "Commit Transaction".to_string(),
            ExecutionPlan::Rollback => "Rollback Transaction".to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::{ColumnConstraint, DataType, SqlValue, Statement, WhereClause};
    use crate::executor::{ColumnInfo, TableSchema};
    use std::collections::HashMap;
    use std::rc::Rc;

    fn create_test_schema() -> HashMap<String, Rc<TableSchema>> {
        let mut schemas = HashMap::new();

        // Users table with single primary key
        schemas.insert(
            "users".to_string(),
            Rc::new(TableSchema {
                name: "users".to_string(),
                columns: vec![
                    ColumnInfo {
                        name: "id".to_string(),
                        data_type: DataType::Integer,
                        constraints: vec![ColumnConstraint::PrimaryKey],
                    },
                    ColumnInfo {
                        name: "name".to_string(),
                        data_type: DataType::Text,
                        constraints: vec![],
                    },
                    ColumnInfo {
                        name: "email".to_string(),
                        data_type: DataType::Text,
                        constraints: vec![],
                    },
                ],
            }),
        );

        schemas
    }

    #[test]
    fn test_primary_key_optimization() {
        let schemas = create_test_schema();
        let planner = QueryPlanner::new(schemas);

        let select = SelectStatement {
            table: "users".to_string(),
            columns: vec!["name".to_string(), "email".to_string()],
            where_clause: Some(WhereClause {
                condition: Condition::Comparison {
                    left: "id".to_string(),
                    operator: ComparisonOperator::Equal,
                    right: SqlValue::Integer(123),
                },
            }),
            order_by: None,
            limit: None,
        };

        let plan = planner.plan(Statement::Select(select)).unwrap();

        match plan {
            ExecutionPlan::PrimaryKeyLookup {
                table, pk_values, ..
            } => {
                assert_eq!(table, "users");
                assert_eq!(pk_values.get("id"), Some(&SqlValue::Integer(123)));
            }
            _ => panic!("Expected PrimaryKeyLookup plan"),
        }
    }

    #[test]
    fn test_table_scan_fallback() {
        let schemas = create_test_schema();
        let planner = QueryPlanner::new(schemas);

        let select = SelectStatement {
            table: "users".to_string(),
            columns: vec!["*".to_string()],
            where_clause: Some(WhereClause {
                condition: Condition::Comparison {
                    left: "name".to_string(),
                    operator: ComparisonOperator::Equal,
                    right: SqlValue::Text("John".to_string()),
                },
            }),
            order_by: None,
            limit: Some(10),
        };

        let plan = planner.plan(Statement::Select(select)).unwrap();

        match plan {
            ExecutionPlan::TableScan {
                table,
                limit,
                early_termination,
                ..
            } => {
                assert_eq!(table, "users");
                assert_eq!(limit, Some(10));
                assert!(early_termination);
            }
            _ => panic!("Expected TableScan plan"),
        }
    }
}
