//! Query planner and optimizer for TegDB
//!
//! This module provides a simple rule-based query planner that takes parsed SQL statements 
//! and generates optimized execution plans. The planner focuses on fast, predictable 
//! optimizations without complex cost estimation.

use crate::parser::{
    SqlValue, Condition, Statement, SelectStatement, InsertStatement, UpdateStatement,
    DeleteStatement, CreateTableStatement, DropTableStatement, ComparisonOperator,
};
use crate::executor::{ColumnInfo, TableSchema};
use crate::Result;
use std::collections::HashMap;
use std::rc::Rc;

/// A query execution plan generated by the planner
#[derive(Debug, Clone)]
pub enum ExecutionPlan {
    /// Direct primary key lookup (most efficient)
    PrimaryKeyLookup {
        table: String,
        pk_values: HashMap<String, SqlValue>,
        selected_columns: Vec<String>,
        additional_filter: Option<Condition>,
    },
    /// Full table scan
    TableScan {
        table: String,
        selected_columns: Vec<String>,
        filter: Option<Condition>,
        limit: Option<u64>,
    },
    /// Insert operation plan
    Insert {
        table: String,
        rows: Vec<HashMap<String, SqlValue>>,
        conflict_resolution: ConflictResolution,
    },
    /// Update operation plan
    Update {
        table: String,
        assignments: Vec<Assignment>,
        scan_plan: Box<ExecutionPlan>,
    },
    /// Delete operation plan
    Delete {
        table: String,
        scan_plan: Box<ExecutionPlan>,
    },
    /// DDL operations
    CreateTable {
        table: String,
        schema: TableSchema,
    },
    DropTable {
        table: String,
        if_exists: bool,
    },
    /// Transaction control
    Begin,
    Commit,
    Rollback,
}

/// Assignment for update operations
#[derive(Debug, Clone)]
pub struct Assignment {
    pub column: String,
    pub value: crate::parser::Expression,
}

/// Conflict resolution strategy for inserts
#[derive(Debug, Clone)]
pub enum ConflictResolution {
    Error,   // Fail on constraint violation
    Ignore,  // Skip conflicting rows
    Replace, // Replace existing rows
}

/// Simple rule-based query planner
pub struct QueryPlanner {
    /// Table schemas for optimization decisions
    table_schemas: HashMap<String, Rc<TableSchema>>,
}

impl QueryPlanner {
    /// Create a new query planner with table schemas
    pub fn new(table_schemas: HashMap<String, Rc<TableSchema>>) -> Self {
        Self { table_schemas }
    }

    /// Generate an optimized execution plan for a SQL statement
    pub fn plan(&self, statement: Statement) -> Result<ExecutionPlan> {
        match statement {
            Statement::Select(select) => self.plan_select(select),
            Statement::Insert(insert) => self.plan_insert(insert),
            Statement::Update(update) => self.plan_update(update),
            Statement::Delete(delete) => self.plan_delete(delete),
            Statement::CreateTable(create) => self.plan_create_table(create),
            Statement::DropTable(drop) => self.plan_drop_table(drop),
            Statement::Begin => Ok(ExecutionPlan::Begin),
            Statement::Commit => Ok(ExecutionPlan::Commit),
            Statement::Rollback => Ok(ExecutionPlan::Rollback),
        }
    }

    /// Plan SELECT statement with primary key optimization
    fn plan_select(&self, select: SelectStatement) -> Result<ExecutionPlan> {
        // Try primary key lookup first (most efficient)
        if let Some(pk_plan) = self.try_primary_key_lookup(&select)? {
            return Ok(pk_plan);
        }

        // Fall back to table scan
        self.plan_table_scan(&select)
    }

    /// Try to create a primary key lookup plan
    fn try_primary_key_lookup(&self, select: &SelectStatement) -> Result<Option<ExecutionPlan>> {
        // Check if we have a WHERE clause that can be used for PK lookup
        if let Some(ref where_clause) = select.where_clause {
            if let Some(pk_values) =
                self.extract_pk_equality_conditions(&select.table, &where_clause.condition)?
            {
                // Check if we have all primary key columns
                let pk_columns = self.get_primary_key_columns(&select.table)?;
                if pk_values.len() == pk_columns.len() {
                    let additional_filter =
                        self.extract_non_pk_conditions(&select.table, &where_clause.condition)?;
                    let selected_columns =
                        self.normalize_selected_columns(&select.table, &select.columns)?;

                    return Ok(Some(ExecutionPlan::PrimaryKeyLookup {
                        table: select.table.clone(),
                        pk_values,
                        selected_columns,
                        additional_filter,
                    }));
                }
            }
        }

        Ok(None)
    }

    /// Plan table scan
    fn plan_table_scan(&self, select: &SelectStatement) -> Result<ExecutionPlan> {
        let selected_columns = self.normalize_selected_columns(&select.table, &select.columns)?;
        let filter = select.where_clause.as_ref().map(|w| w.condition.clone());

        Ok(ExecutionPlan::TableScan {
            table: select.table.clone(),
            selected_columns,
            filter,
            limit: select.limit,
        })
    }

    /// Plan INSERT statement
    fn plan_insert(&self, insert: InsertStatement) -> Result<ExecutionPlan> {
        // Convert values to HashMap format
        let mut rows = Vec::with_capacity(insert.values.len());
        for value_row in insert.values {
            let mut row_data = HashMap::with_capacity(insert.columns.len());
            for (i, col_name) in insert.columns.iter().enumerate() {
                if let Some(value) = value_row.get(i) {
                    row_data.insert(col_name.clone(), value.clone());
                }
            }
            rows.push(row_data);
        }

        Ok(ExecutionPlan::Insert {
            table: insert.table,
            rows,
            conflict_resolution: ConflictResolution::Error,
        })
    }

    /// Plan UPDATE statement
    fn plan_update(&self, update: UpdateStatement) -> Result<ExecutionPlan> {
        // Convert assignments to planner format
        let assignments: Vec<Assignment> = update
            .assignments
            .into_iter()
            .map(|a| Assignment {
                column: a.column,
                value: a.value,
            })
            .collect();

        // Always expand ["*"] to all columns for scan plan
        let all_columns = self.normalize_selected_columns(&update.table, &["*".to_string()])?;

        // Create scan plan for the rows to update
        let scan_plan = if let Some(ref where_clause) = update.where_clause {
            // Try to optimize the scan based on WHERE clause
            if let Some(pk_values) =
                self.extract_pk_equality_conditions(&update.table, &where_clause.condition)?
            {
                let pk_columns = self.get_primary_key_columns(&update.table)?;
                if pk_values.len() == pk_columns.len() {
                    ExecutionPlan::PrimaryKeyLookup {
                        table: update.table.clone(),
                        pk_values,
                        selected_columns: all_columns.clone(),
                        additional_filter: None,
                    }
                } else {
                    ExecutionPlan::TableScan {
                        table: update.table.clone(),
                        selected_columns: all_columns.clone(),
                        filter: Some(where_clause.condition.clone()),
                        limit: None,
                    }
                }
            } else {
                ExecutionPlan::TableScan {
                    table: update.table.clone(),
                    selected_columns: all_columns.clone(),
                    filter: Some(where_clause.condition.clone()),
                    limit: None,
                }
            }
        } else {
            // No WHERE clause - scan all rows
            ExecutionPlan::TableScan {
                table: update.table.clone(),
                selected_columns: all_columns.clone(),
                filter: None,
                limit: None,
            }
        };

        Ok(ExecutionPlan::Update {
            table: update.table,
            assignments,
            scan_plan: Box::new(scan_plan),
        })
    }

    /// Plan DELETE statement
    fn plan_delete(&self, delete: DeleteStatement) -> Result<ExecutionPlan> {
        // Always expand ["*"] to all columns for scan plan
        let all_columns = self.normalize_selected_columns(&delete.table, &["*".to_string()])?;

        // Create scan plan for the rows to delete
        let scan_plan = if let Some(ref where_clause) = delete.where_clause {
            // Try to optimize the scan based on WHERE clause
            if let Some(pk_values) =
                self.extract_pk_equality_conditions(&delete.table, &where_clause.condition)?
            {
                let pk_columns = self.get_primary_key_columns(&delete.table)?;
                if pk_values.len() == pk_columns.len() {
                    ExecutionPlan::PrimaryKeyLookup {
                        table: delete.table.clone(),
                        pk_values,
                        selected_columns: all_columns.clone(),
                        additional_filter: None,
                    }
                } else {
                    ExecutionPlan::TableScan {
                        table: delete.table.clone(),
                        selected_columns: all_columns.clone(),
                        filter: Some(where_clause.condition.clone()),
                        limit: None,
                    }
                }
            } else {
                ExecutionPlan::TableScan {
                    table: delete.table.clone(),
                    selected_columns: all_columns.clone(),
                    filter: Some(where_clause.condition.clone()),
                    limit: None,
                }
            }
        } else {
            // No WHERE clause - scan all rows
            ExecutionPlan::TableScan {
                table: delete.table.clone(),
                selected_columns: all_columns.clone(),
                filter: None,
                limit: None,
            }
        };

        Ok(ExecutionPlan::Delete {
            table: delete.table,
            scan_plan: Box::new(scan_plan),
        })
    }

    /// Plan CREATE TABLE statement
    fn plan_create_table(&self, create: CreateTableStatement) -> Result<ExecutionPlan> {
        let schema = TableSchema {
            name: create.table.clone(),
            columns: create
                .columns
                .iter()
                .map(|col| ColumnInfo {
                    name: col.name.clone(),
                    data_type: col.data_type.clone(),
                    constraints: col.constraints.clone(),
                })
                .collect(),
        };

        Ok(ExecutionPlan::CreateTable {
            table: create.table,
            schema,
        })
    }

    /// Plan DROP TABLE statement
    fn plan_drop_table(&self, drop: DropTableStatement) -> Result<ExecutionPlan> {
        Ok(ExecutionPlan::DropTable {
            table: drop.table,
            if_exists: drop.if_exists,
        })
    }

    /// Extract primary key equality conditions from WHERE clause
    fn extract_pk_equality_conditions(
        &self,
        table_name: &str,
        condition: &Condition,
    ) -> Result<Option<HashMap<String, SqlValue>>> {
        let pk_columns = self.get_primary_key_columns(table_name)?;
        let mut pk_values = HashMap::new();

        Self::collect_pk_equality_values(condition, &pk_columns, &mut pk_values);

        // Check if we have values for ALL primary key columns
        if pk_values.len() == pk_columns.len() {
            Ok(Some(pk_values))
        } else {
            Ok(None)
        }
    }

    /// Recursively collect primary key equality values from conditions
    fn collect_pk_equality_values(
        condition: &Condition,
        pk_columns: &[String],
        pk_values: &mut HashMap<String, SqlValue>,
    ) {
        match condition {
            Condition::Comparison {
                left,
                operator,
                right,
            } => {
                if let ComparisonOperator::Equal = operator {
                    if pk_columns.contains(left) && !pk_values.contains_key(left) {
                        pk_values.insert(left.clone(), right.clone());
                    }
                }
            }
            Condition::And(left_cond, right_cond) => {
                Self::collect_pk_equality_values(left_cond, pk_columns, pk_values);
                Self::collect_pk_equality_values(right_cond, pk_columns, pk_values);
            }
            Condition::Or(_, _) => {
                // For OR conditions, we cannot optimize with PK lookup
            }
        }
    }

    /// Extract non-primary key conditions for additional filtering
    fn extract_non_pk_conditions(
        &self,
        table_name: &str,
        condition: &Condition,
    ) -> Result<Option<Condition>> {
        let pk_columns = self.get_primary_key_columns(table_name)?;

        fn filter_non_pk_conditions(
            condition: &Condition,
            pk_columns: &[String],
        ) -> Option<Condition> {
            match condition {
                Condition::Comparison {
                    left,
                    operator: _,
                    right: _,
                } => {
                    if pk_columns.contains(left) {
                        None // This is a PK condition, filter it out
                    } else {
                        Some(condition.clone()) // Keep non-PK conditions
                    }
                }
                Condition::And(left, right) => {
                    let left_filtered = filter_non_pk_conditions(left, pk_columns);
                    let right_filtered = filter_non_pk_conditions(right, pk_columns);

                    match (left_filtered, right_filtered) {
                        (Some(l), Some(r)) => Some(Condition::And(Box::new(l), Box::new(r))),
                        (Some(l), None) => Some(l),
                        (None, Some(r)) => Some(r),
                        (None, None) => None,
                    }
                }
                Condition::Or(left, right) => {
                    let left_filtered = filter_non_pk_conditions(left, pk_columns);
                    let right_filtered = filter_non_pk_conditions(right, pk_columns);

                    match (left_filtered, right_filtered) {
                        (Some(l), Some(r)) => Some(Condition::Or(Box::new(l), Box::new(r))),
                        (Some(l), None) => Some(l),
                        (None, Some(r)) => Some(r),
                        (None, None) => None,
                    }
                }
            }
        }

        Ok(filter_non_pk_conditions(condition, &pk_columns))
    }

    /// Normalize selected columns: if ["*"] is given, expand to all columns from the schema
    fn normalize_selected_columns(
        &self,
        table_name: &str,
        columns: &[String],
    ) -> Result<Vec<String>> {
        if columns.len() == 1 && columns[0] == "*" {
            // Expand * to all columns from the schema
            if let Some(schema) = self.table_schemas.get(table_name) {
                Ok(schema.columns.iter().map(|c| c.name.clone()).collect())
            } else {
                Err(crate::Error::Other(format!(
                    "Table '{table_name}' not found for column expansion"
                )))
            }
        } else {
            Ok(columns.to_vec())
        }
    }

    /// Get primary key columns for a table
    fn get_primary_key_columns(&self, table_name: &str) -> Result<Vec<String>> {
        if let Some(schema) = self.table_schemas.get(table_name) {
            let pk_columns: Vec<String> = schema
                .columns
                .iter()
                .filter(|col| {
                    col.constraints
                        .contains(&crate::parser::ColumnConstraint::PrimaryKey)
                })
                .map(|col| col.name.clone())
                .collect();
            Ok(pk_columns)
        } else {
            Err(crate::Error::Other(format!(
                "Table '{table_name}' not found"
            )))
        }
    }

    /// Update table schemas (called when DDL operations occur)
    pub fn update_table_schema(&mut self, table_name: String, schema: Rc<TableSchema>) {
        self.table_schemas.insert(table_name, schema);
    }

    /// Remove table schema (called when table is dropped)
    pub fn remove_table_schema(&mut self, table_name: &str) {
        self.table_schemas.remove(table_name);
    }

    /// Get current table schemas
    pub fn table_schemas(&self) -> &HashMap<String, Rc<TableSchema>> {
        &self.table_schemas
    }
}

/// Helper functions for plan analysis and debugging
impl ExecutionPlan {
    /// Get the main table involved in this plan
    pub fn primary_table(&self) -> Option<&str> {
        match self {
            ExecutionPlan::PrimaryKeyLookup { table, .. } => Some(table),
            ExecutionPlan::TableScan { table, .. } => Some(table),
            ExecutionPlan::Insert { table, .. } => Some(table),
            ExecutionPlan::Update { table, .. } => Some(table),
            ExecutionPlan::Delete { table, .. } => Some(table),
            ExecutionPlan::CreateTable { table, .. } => Some(table),
            ExecutionPlan::DropTable { table, .. } => Some(table),
            _ => None,
        }
    }

    /// Check if this plan involves a table scan
    pub fn requires_table_scan(&self) -> bool {
        match self {
            ExecutionPlan::TableScan { .. } => true,
            ExecutionPlan::Update { scan_plan, .. } => scan_plan.requires_table_scan(),
            ExecutionPlan::Delete { scan_plan, .. } => scan_plan.requires_table_scan(),
            _ => false,
        }
    }

    /// Get a human-readable description of the plan
    pub fn describe(&self) -> String {
        match self {
            ExecutionPlan::PrimaryKeyLookup {
                table, pk_values, ..
            } => {
                format!(
                    "Primary Key Lookup on {} (keys: {})",
                    table,
                    pk_values.len()
                )
            }
            ExecutionPlan::TableScan { table, .. } => {
                format!("Table Scan on {table}")
            }
            ExecutionPlan::Insert { table, rows, .. } => {
                format!("Insert into {} ({} rows)", table, rows.len())
            }
            ExecutionPlan::Update {
                table, scan_plan, ..
            } => {
                format!("Update {} via {}", table, scan_plan.describe())
            }
            ExecutionPlan::Delete {
                table, scan_plan, ..
            } => {
                format!("Delete from {} via {}", table, scan_plan.describe())
            }
            ExecutionPlan::CreateTable { table, .. } => {
                format!("Create Table {table}")
            }
            ExecutionPlan::DropTable { table, .. } => {
                format!("Drop Table {table}")
            }
            ExecutionPlan::Begin => "Begin Transaction".to_string(),
            ExecutionPlan::Commit => "Commit Transaction".to_string(),
            ExecutionPlan::Rollback => "Rollback Transaction".to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::{ColumnConstraint, DataType, SqlValue, Statement, WhereClause};
    use crate::executor::{ColumnInfo, TableSchema};
    use std::collections::HashMap;
    use std::rc::Rc;

    fn create_test_schema() -> HashMap<String, Rc<TableSchema>> {
        let mut schemas = HashMap::new();

        // Users table with single primary key
        schemas.insert(
            "users".to_string(),
            Rc::new(TableSchema {
                name: "users".to_string(),
                columns: vec![
                    ColumnInfo {
                        name: "id".to_string(),
                        data_type: DataType::Integer,
                        constraints: vec![ColumnConstraint::PrimaryKey],
                    },
                    ColumnInfo {
                        name: "name".to_string(),
                        data_type: DataType::Text,
                        constraints: vec![],
                    },
                    ColumnInfo {
                        name: "email".to_string(),
                        data_type: DataType::Text,
                        constraints: vec![],
                    },
                ],
            }),
        );

        schemas
    }

    #[test]
    fn test_primary_key_optimization() {
        let schemas = create_test_schema();
        let planner = QueryPlanner::new(schemas);

        let select = SelectStatement {
            table: "users".to_string(),
            columns: vec!["name".to_string(), "email".to_string()],
            where_clause: Some(WhereClause {
                condition: Condition::Comparison {
                    left: "id".to_string(),
                    operator: ComparisonOperator::Equal,
                    right: SqlValue::Integer(123),
                },
            }),
            limit: None,
        };

        let plan = planner.plan(Statement::Select(select)).unwrap();

        match plan {
            ExecutionPlan::PrimaryKeyLookup {
                table, pk_values, ..
            } => {
                assert_eq!(table, "users");
                assert_eq!(pk_values.get("id"), Some(&SqlValue::Integer(123)));
            }
            _ => panic!("Expected PrimaryKeyLookup plan"),
        }
    }

    #[test]
    fn test_table_scan_fallback() {
        let schemas = create_test_schema();
        let planner = QueryPlanner::new(schemas);

        let select = SelectStatement {
            table: "users".to_string(),
            columns: vec!["*".to_string()],
            where_clause: Some(WhereClause {
                condition: Condition::Comparison {
                    left: "name".to_string(),
                    operator: ComparisonOperator::Equal,
                    right: SqlValue::Text("John".to_string()),
                },
            }),
            limit: Some(10),
        };

        let plan = planner.plan(Statement::Select(select)).unwrap();

        match plan {
            ExecutionPlan::TableScan {
                table,
                limit,
                ..
            } => {
                assert_eq!(table, "users");
                assert_eq!(limit, Some(10));
            }
            _ => panic!("Expected TableScan plan"),
        }
    }
}
