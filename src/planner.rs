//! Query planner and optimizer for TegDB
//!
//! This module provides a query planner that takes parsed SQL statements and generates
//! optimized execution plans. The planner sits between the parser and executor,
//! similar to PostgreSQL and SQLite architectures.

use crate::executor::{ColumnInfo, TableSchema};
#[cfg(test)]
use crate::parser::WhereClause;
use crate::parser::{
    ComparisonOperator, Condition, CreateTableStatement, DeleteStatement, DropTableStatement,
    InsertStatement, SelectStatement, SqlValue, Statement, UpdateStatement,
};
use crate::Result;
use std::collections::HashMap;

/// A query execution plan generated by the planner
#[derive(Debug, Clone)]
pub enum ExecutionPlan {
    /// Direct primary key lookup (most efficient)
    PrimaryKeyLookup {
        table: String,
        pk_values: HashMap<String, SqlValue>,
        selected_columns: Vec<String>,
        additional_filter: Option<Condition>,
    },
    /// Index scan (if secondary indexes are implemented)
    IndexScan {
        table: String,
        index_name: String,
        key_conditions: Vec<IndexCondition>,
        selected_columns: Vec<String>,
        filter: Option<Condition>,
        limit: Option<u64>,
    },
    /// Full table scan with optimizations
    TableScan {
        table: String,
        selected_columns: Vec<String>,
        filter: Option<Condition>,
        limit: Option<u64>,
        early_termination: bool,
    },
    /// Insert operation plan
    Insert {
        table: String,
        rows: Vec<HashMap<String, SqlValue>>,
        conflict_resolution: ConflictResolution,
    },
    /// Update operation plan
    Update {
        table: String,
        assignments: Vec<Assignment>,
        scan_plan: Box<ExecutionPlan>,
    },
    /// Delete operation plan
    Delete {
        table: String,
        scan_plan: Box<ExecutionPlan>,
    },
    /// DDL operations
    CreateTable {
        table: String,
        schema: TableSchema,
    },
    DropTable {
        table: String,
        if_exists: bool,
    },
    /// Transaction control
    Begin,
    Commit,
    Rollback,
}

/// Index condition for index scans
#[derive(Debug, Clone)]
pub struct IndexCondition {
    pub column: String,
    pub operator: ComparisonOperator,
    pub value: SqlValue,
}

/// Assignment for update operations
#[derive(Debug, Clone)]
pub struct Assignment {
    pub column: String,
    pub value: crate::parser::Expression,
}

/// Conflict resolution strategy for inserts
#[derive(Debug, Clone)]
pub enum ConflictResolution {
    Error,   // Fail on constraint violation
    Ignore,  // Skip conflicting rows
    Replace, // Replace existing rows
}

/// Cost estimation for different plan types
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct Cost {
    pub io_cost: f64,     // Estimated I/O operations
    pub cpu_cost: f64,    // Estimated CPU operations
    pub memory_cost: f64, // Estimated memory usage
}

impl Cost {
    pub fn new(io_cost: f64, cpu_cost: f64, memory_cost: f64) -> Self {
        Self {
            io_cost,
            cpu_cost,
            memory_cost,
        }
    }

    pub fn total(&self) -> f64 {
        self.io_cost + self.cpu_cost + self.memory_cost
    }

    pub fn zero() -> Self {
        Self::new(0.0, 0.0, 0.0)
    }
}

/// Query planner that generates optimized execution plans
pub struct QueryPlanner {
    /// Table schemas for optimization decisions
    table_schemas: HashMap<String, TableSchema>,
    /// Table statistics for cost estimation
    table_stats: HashMap<String, TableStatistics>,
    /// Configuration for optimization decisions
    config: PlannerConfig,
}

/// Statistics about tables for cost-based optimization
#[derive(Debug, Clone)]
pub struct TableStatistics {
    pub row_count: u64,
    pub avg_row_size: usize,
    pub column_stats: HashMap<String, ColumnStatistics>,
}

/// Statistics about individual columns
#[derive(Debug, Clone)]
pub struct ColumnStatistics {
    pub distinct_values: u64,
    pub null_ratio: f64,
    pub most_common_values: Vec<(SqlValue, f64)>, // value, frequency
}

/// Configuration for the query planner
#[derive(Debug, Clone)]
pub struct PlannerConfig {
    /// Cost weights for different operations
    pub seq_scan_cost: f64,
    pub index_scan_cost: f64,
    pub pk_lookup_cost: f64,
    pub cpu_tuple_cost: f64,
    pub memory_page_cost: f64,

    /// Optimization thresholds
    pub enable_pk_optimization: bool,
    pub enable_predicate_pushdown: bool,
    pub enable_limit_pushdown: bool,
    pub small_table_threshold: u64, // Rows below which we prefer table scan
}

impl Default for PlannerConfig {
    fn default() -> Self {
        Self {
            seq_scan_cost: 1.0,
            index_scan_cost: 0.1,
            pk_lookup_cost: 0.01,
            cpu_tuple_cost: 0.01,
            memory_page_cost: 1.0,
            enable_pk_optimization: true,
            enable_predicate_pushdown: true,
            enable_limit_pushdown: true,
            small_table_threshold: 1000,
        }
    }
}

impl QueryPlanner {
    /// Create a new query planner with table schemas
    pub fn new(table_schemas: HashMap<String, TableSchema>) -> Self {
        Self {
            table_schemas,
            table_stats: HashMap::new(),
            config: PlannerConfig::default(),
        }
    }

    /// Create a planner with custom configuration
    pub fn with_config(table_schemas: HashMap<String, TableSchema>, config: PlannerConfig) -> Self {
        Self {
            table_schemas,
            table_stats: HashMap::new(),
            config,
        }
    }

    /// Update table statistics for better cost estimation
    pub fn update_table_stats(&mut self, table: String, stats: TableStatistics) {
        self.table_stats.insert(table, stats);
    }

    /// Generate an optimized execution plan for a SQL statement
    pub fn plan(&self, statement: Statement) -> Result<ExecutionPlan> {
        match statement {
            Statement::Select(select) => self.plan_select(select),
            Statement::Insert(insert) => self.plan_insert(insert),
            Statement::Update(update) => self.plan_update(update),
            Statement::Delete(delete) => self.plan_delete(delete),
            Statement::CreateTable(create) => self.plan_create_table(create),
            Statement::DropTable(drop) => self.plan_drop_table(drop),
            Statement::Begin => Ok(ExecutionPlan::Begin),
            Statement::Commit => Ok(ExecutionPlan::Commit),
            Statement::Rollback => Ok(ExecutionPlan::Rollback),
        }
    }

    /// Plan a SELECT statement with multiple optimization strategies
    fn plan_select(&self, select: SelectStatement) -> Result<ExecutionPlan> {
        let table_name = &select.table;

        // Validate table exists
        if !self.table_schemas.contains_key(table_name) {
            return Err(crate::Error::Other(format!(
                "Table '{}' not found",
                table_name
            )));
        }

        // Try different plan types in order of efficiency
        let mut candidate_plans = Vec::new();

        // 1. Try primary key lookup (most efficient)
        if self.config.enable_pk_optimization {
            if let Some(plan) = self.try_primary_key_lookup(&select)? {
                candidate_plans.push((plan, self.estimate_pk_lookup_cost(table_name)));
            }
        }

        // 2. Try index scans (if indexes existed)
        // TODO: Implement when secondary indexes are added

        // 3. Fall back to table scan with optimizations
        let table_scan_plan = self.plan_table_scan(&select)?;
        let table_scan_cost = self.estimate_table_scan_cost(table_name, &select);
        candidate_plans.push((table_scan_plan, table_scan_cost));

        // Choose the plan with lowest cost
        let best_plan = candidate_plans
            .into_iter()
            .min_by(|(_, cost1), (_, cost2)| cost1.total().partial_cmp(&cost2.total()).unwrap())
            .map(|(plan, _)| plan)
            .unwrap(); // We always have at least the table scan plan

        Ok(best_plan)
    }

    /// Try to create a primary key lookup plan
    fn try_primary_key_lookup(&self, select: &SelectStatement) -> Result<Option<ExecutionPlan>> {
        if let Some(ref where_clause) = select.where_clause {
            if let Some(pk_values) =
                self.extract_pk_equality_conditions(&select.table, &where_clause.condition)?
            {
                return Ok(Some(ExecutionPlan::PrimaryKeyLookup {
                    table: select.table.clone(),
                    pk_values,
                    selected_columns: self
                        .normalize_selected_columns(&select.table, &select.columns)?,
                    additional_filter: self
                        .extract_non_pk_conditions(&select.table, &where_clause.condition)?,
                }));
            }
        }
        Ok(None)
    }

    /// Plan a table scan with optimizations
    fn plan_table_scan(&self, select: &SelectStatement) -> Result<ExecutionPlan> {
        let filter = select.where_clause.as_ref().map(|w| w.condition.clone());
        let selected_columns = self.normalize_selected_columns(&select.table, &select.columns)?;

        // Enable early termination if we have a LIMIT and simple conditions
        let early_termination = select.limit.is_some() && Self::is_simple_filter(filter.as_ref());

        Ok(ExecutionPlan::TableScan {
            table: select.table.clone(),
            selected_columns,
            filter,
            limit: select.limit,
            early_termination,
        })
    }

    /// Plan an INSERT statement
    fn plan_insert(&self, insert: InsertStatement) -> Result<ExecutionPlan> {
        // Validate table exists
        if !self.table_schemas.contains_key(&insert.table) {
            return Err(crate::Error::Other(format!(
                "Table '{}' not found",
                insert.table
            )));
        }

        // Convert insert data to row format
        let mut rows = Vec::new();
        for values in insert.values {
            let mut row = HashMap::new();
            for (i, value) in values.into_iter().enumerate() {
                if let Some(column) = insert.columns.get(i) {
                    row.insert(column.clone(), value);
                }
            }
            rows.push(row);
        }

        Ok(ExecutionPlan::Insert {
            table: insert.table,
            rows,
            conflict_resolution: ConflictResolution::Error, // Default behavior
        })
    }

    /// Plan an UPDATE statement
    fn plan_update(&self, update: UpdateStatement) -> Result<ExecutionPlan> {
        // Create a SELECT plan to find rows to update
        let select = SelectStatement {
            table: update.table.clone(),
            // Only need the primary key for updates, not all columns
            columns: self.get_primary_key_columns_as_vec(&update.table)?,
            where_clause: update.where_clause.clone(),
            order_by: None, // Updates don't have LIMIT
            limit: None,
        };

        let scan_plan = Box::new(self.plan_select(select)?);

        let assignments = update
            .assignments
            .into_iter()
            .map(|a| Assignment {
                column: a.column,
                value: a.value,
            })
            .collect();

        Ok(ExecutionPlan::Update {
            table: update.table,
            assignments,
            scan_plan,
        })
    }

    /// Plan a DELETE statement
    fn plan_delete(&self, delete: DeleteStatement) -> Result<ExecutionPlan> {
        // Create a SELECT plan to find rows to delete
        let select = SelectStatement {
            table: delete.table.clone(),
            // Only need the primary key for deletion, not all columns
            columns: self.get_primary_key_columns_as_vec(&delete.table)?,
            where_clause: delete.where_clause.clone(),
            order_by: None, // Deletes don't have LIMIT
            limit: None,
        };

        let scan_plan = Box::new(self.plan_select(select)?);

        Ok(ExecutionPlan::Delete {
            table: delete.table,
            scan_plan,
        })
    }

    /// Plan a CREATE TABLE statement
    fn plan_create_table(&self, create: CreateTableStatement) -> Result<ExecutionPlan> {
        // Convert parser schema to executor schema
        let schema = TableSchema {
            name: create.table.clone(),
            columns: create
                .columns
                .iter()
                .map(|col| ColumnInfo {
                    name: col.name.clone(),
                    data_type: col.data_type.clone(),
                    constraints: col.constraints.clone(),
                })
                .collect(),
        };

        Ok(ExecutionPlan::CreateTable {
            table: create.table,
            schema,
        })
    }

    /// Plan a DROP TABLE statement
    fn plan_drop_table(&self, drop: DropTableStatement) -> Result<ExecutionPlan> {
        Ok(ExecutionPlan::DropTable {
            table: drop.table,
            if_exists: drop.if_exists,
        })
    }

    /// Extract primary key equality conditions from WHERE clause
    fn extract_pk_equality_conditions(
        &self,
        table_name: &str,
        condition: &Condition,
    ) -> Result<Option<HashMap<String, SqlValue>>> {
        let pk_columns = self.get_primary_key_columns(table_name)?;
        let mut pk_values = HashMap::new();

        Self::collect_pk_equality_values(condition, &pk_columns, &mut pk_values);

        // Check if we have values for ALL primary key columns
        if pk_values.len() == pk_columns.len() {
            Ok(Some(pk_values))
        } else {
            Ok(None)
        }
    }

    /// Recursively collect primary key equality values from conditions
    fn collect_pk_equality_values(
        condition: &Condition,
        pk_columns: &[String],
        pk_values: &mut HashMap<String, SqlValue>,
    ) {
        match condition {
            Condition::Comparison {
                left,
                operator,
                right,
            } => {
                if let ComparisonOperator::Equal = operator {
                    if pk_columns.contains(left) && !pk_values.contains_key(left) {
                        pk_values.insert(left.clone(), right.clone());
                    }
                }
            }
            Condition::And(left_cond, right_cond) => {
                Self::collect_pk_equality_values(left_cond, pk_columns, pk_values);
                Self::collect_pk_equality_values(right_cond, pk_columns, pk_values);
            }
            Condition::Or(_, _) => {
                // For OR conditions, we cannot optimize with PK lookup
            }
        }
    }

    /// Extract non-primary key conditions for additional filtering
    fn extract_non_pk_conditions(
        &self,
        table_name: &str,
        condition: &Condition,
    ) -> Result<Option<Condition>> {
        let pk_columns = self.get_primary_key_columns(table_name)?;

        fn filter_non_pk_conditions(
            condition: &Condition,
            pk_columns: &[String],
        ) -> Option<Condition> {
            match condition {
                Condition::Comparison {
                    left,
                    operator,
                    right: _,
                } => {
                    if pk_columns.contains(left) && matches!(operator, ComparisonOperator::Equal) {
                        None // This is a PK condition, filter it out
                    } else {
                        Some(condition.clone()) // Keep non-PK conditions
                    }
                }
                Condition::And(left, right) => {
                    let left_filtered = filter_non_pk_conditions(left, pk_columns);
                    let right_filtered = filter_non_pk_conditions(right, pk_columns);

                    match (left_filtered, right_filtered) {
                        (Some(l), Some(r)) => Some(Condition::And(Box::new(l), Box::new(r))),
                        (Some(l), None) => Some(l),
                        (None, Some(r)) => Some(r),
                        (None, None) => None,
                    }
                }
                Condition::Or(left, right) => {
                    let left_filtered = filter_non_pk_conditions(left, pk_columns);
                    let right_filtered = filter_non_pk_conditions(right, pk_columns);

                    match (left_filtered, right_filtered) {
                        (Some(l), Some(r)) => Some(Condition::Or(Box::new(l), Box::new(r))),
                        (Some(l), None) => Some(l),
                        (None, Some(r)) => Some(r),
                        (None, None) => None,
                    }
                }
            }
        }

        Ok(filter_non_pk_conditions(condition, &pk_columns))
    }

    /// Normalize selected columns (handle * expansion)
    fn normalize_selected_columns(
        &self,
        table_name: &str,
        columns: &[String],
    ) -> Result<Vec<String>> {
        if columns.len() == 1 && columns[0] == "*" {
            // Expand * to all columns in schema order
            if let Some(schema) = self.table_schemas.get(table_name) {
                Ok(schema.columns.iter().map(|c| c.name.clone()).collect())
            } else {
                Err(crate::Error::Other(format!(
                    "Table '{}' not found",
                    table_name
                )))
            }
        } else {
            Ok(columns.to_vec())
        }
    }

    /// Check if a filter is simple enough for early termination optimization
    fn is_simple_filter(filter: Option<&Condition>) -> bool {
        match filter {
            None => true,
            Some(Condition::Comparison { .. }) => true,
            Some(Condition::And(left, right)) => {
                Self::is_simple_filter(Some(left)) && Self::is_simple_filter(Some(right))
            }
            Some(Condition::Or(_, _)) => false, // OR conditions are more complex
        }
    }

    /// Get primary key columns for a table
    fn get_primary_key_columns(&self, table_name: &str) -> Result<Vec<String>> {
        if let Some(schema) = self.table_schemas.get(table_name) {
            let pk_columns: Vec<String> = schema
                .columns
                .iter()
                .filter(|col| {
                    col.constraints
                        .contains(&crate::parser::ColumnConstraint::PrimaryKey)
                })
                .map(|col| col.name.clone())
                .collect();
            Ok(pk_columns)
        } else {
            Err(crate::Error::Other(format!(
                "Table '{}' not found",
                table_name
            )))
        }
    }

    /// Helper to get primary key columns as a Vec<String> for selection
    fn get_primary_key_columns_as_vec(&self, table_name: &str) -> Result<Vec<String>> {
        let pks = self.get_primary_key_columns(table_name)?;
        if pks.is_empty() {
            // If no explicit PK, we need all columns to uniquely identify rows for deletion
            // This is a fallback and assumes row identity is based on all columns
            self.normalize_selected_columns(table_name, &["*".to_string()])
        } else {
            Ok(pks)
        }
    }

    /// Estimate cost for a primary key lookup
    fn estimate_pk_lookup_cost(&self, table_name: &str) -> Cost {
        let default_stats = TableStatistics {
            row_count: 1,
            avg_row_size: 100,
            column_stats: HashMap::new(),
        };
        let stats = self.table_stats.get(table_name).unwrap_or(&default_stats);

        Cost::new(
            self.config.pk_lookup_cost,       // Very low I/O
            self.config.cpu_tuple_cost * 1.0, // Minimal CPU
            (stats.avg_row_size as f64 / 4096.0) * self.config.memory_page_cost, // Memory for one row
        )
    }

    /// Estimate cost for a table scan
    fn estimate_table_scan_cost(&self, table_name: &str, select: &SelectStatement) -> Cost {
        let row_count = self
            .table_stats
            .get(table_name)
            .map(|stats| stats.row_count)
            .unwrap_or(1000); // Default estimate

        let effective_rows = if let Some(limit) = select.limit {
            std::cmp::min(row_count, limit)
        } else {
            row_count
        };

        Cost::new(
            self.config.seq_scan_cost * effective_rows as f64,
            self.config.cpu_tuple_cost * effective_rows as f64,
            self.config.memory_page_cost * (effective_rows as f64 / 100.0), // Rough memory estimate
        )
    }

    /// Update table schemas (called when DDL operations occur)
    pub fn update_table_schema(&mut self, table_name: String, schema: TableSchema) {
        self.table_schemas.insert(table_name, schema);
    }

    /// Remove table schema (called when table is dropped)
    pub fn remove_table_schema(&mut self, table_name: &str) {
        self.table_schemas.remove(table_name);
        self.table_stats.remove(table_name);
    }

    /// Get current table schemas
    pub fn table_schemas(&self) -> &HashMap<String, TableSchema> {
        &self.table_schemas
    }

    /// Get configuration
    pub fn config(&self) -> &PlannerConfig {
        &self.config
    }

    /// Update configuration
    pub fn update_config(&mut self, config: PlannerConfig) {
        self.config = config;
    }
}

/// Helper functions for plan analysis and debugging
impl ExecutionPlan {
    /// Get the main table involved in this plan
    pub fn primary_table(&self) -> Option<&str> {
        match self {
            ExecutionPlan::PrimaryKeyLookup { table, .. } => Some(table),
            ExecutionPlan::IndexScan { table, .. } => Some(table),
            ExecutionPlan::TableScan { table, .. } => Some(table),
            ExecutionPlan::Insert { table, .. } => Some(table),
            ExecutionPlan::Update { table, .. } => Some(table),
            ExecutionPlan::Delete { table, .. } => Some(table),
            ExecutionPlan::CreateTable { table, .. } => Some(table),
            ExecutionPlan::DropTable { table, .. } => Some(table),
            _ => None,
        }
    }

    /// Check if this plan involves a table scan
    pub fn requires_table_scan(&self) -> bool {
        match self {
            ExecutionPlan::TableScan { .. } => true,
            ExecutionPlan::Update { scan_plan, .. } => scan_plan.requires_table_scan(),
            ExecutionPlan::Delete { scan_plan, .. } => scan_plan.requires_table_scan(),
            _ => false,
        }
    }

    /// Get a human-readable description of the plan
    pub fn describe(&self) -> String {
        match self {
            ExecutionPlan::PrimaryKeyLookup {
                table, pk_values, ..
            } => {
                format!(
                    "Primary Key Lookup on {} (keys: {})",
                    table,
                    pk_values.len()
                )
            }
            ExecutionPlan::IndexScan {
                table, index_name, ..
            } => {
                format!("Index Scan on {}.{}", table, index_name)
            }
            ExecutionPlan::TableScan {
                table,
                early_termination,
                ..
            } => {
                if *early_termination {
                    format!("Table Scan on {} (with early termination)", table)
                } else {
                    format!("Table Scan on {}", table)
                }
            }
            ExecutionPlan::Insert { table, rows, .. } => {
                format!("Insert into {} ({} rows)", table, rows.len())
            }
            ExecutionPlan::Update {
                table, scan_plan, ..
            } => {
                format!("Update {} via {}", table, scan_plan.describe())
            }
            ExecutionPlan::Delete {
                table, scan_plan, ..
            } => {
                format!("Delete from {} via {}", table, scan_plan.describe())
            }
            ExecutionPlan::CreateTable { table, .. } => {
                format!("Create Table {}", table)
            }
            ExecutionPlan::DropTable { table, .. } => {
                format!("Drop Table {}", table)
            }
            ExecutionPlan::Begin => "Begin Transaction".to_string(),
            ExecutionPlan::Commit => "Commit Transaction".to_string(),
            ExecutionPlan::Rollback => "Rollback Transaction".to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::DataType;

    fn create_test_schema() -> HashMap<String, TableSchema> {
        let mut schemas = HashMap::new();

        // Users table with single primary key
        schemas.insert(
            "users".to_string(),
            TableSchema {
                name: "users".to_string(),
                columns: vec![
                    ColumnInfo {
                        name: "id".to_string(),
                        data_type: DataType::Integer,
                        constraints: vec![crate::parser::ColumnConstraint::PrimaryKey],
                    },
                    ColumnInfo {
                        name: "name".to_string(),
                        data_type: DataType::Text,
                        constraints: vec![],
                    },
                    ColumnInfo {
                        name: "email".to_string(),
                        data_type: DataType::Text,
                        constraints: vec![crate::parser::ColumnConstraint::Unique],
                    },
                ],
            },
        );

        schemas
    }

    #[test]
    fn test_primary_key_optimization() {
        let schemas = create_test_schema();
        let planner = QueryPlanner::new(schemas);

        let select = SelectStatement {
            table: "users".to_string(),
            columns: vec!["name".to_string(), "email".to_string()],
            where_clause: Some(WhereClause {
                condition: Condition::Comparison {
                    left: "id".to_string(),
                    operator: ComparisonOperator::Equal,
                    right: SqlValue::Integer(123),
                },
            }),
            order_by: None,
            limit: None,
        };

        let plan = planner.plan_select(select).unwrap();

        match plan {
            ExecutionPlan::PrimaryKeyLookup {
                table, pk_values, ..
            } => {
                assert_eq!(table, "users");
                assert_eq!(pk_values.get("id"), Some(&SqlValue::Integer(123)));
            }
            _ => panic!("Expected PrimaryKeyLookup plan"),
        }
    }

    #[test]
    fn test_table_scan_fallback() {
        let schemas = create_test_schema();
        let planner = QueryPlanner::new(schemas);

        let select = SelectStatement {
            table: "users".to_string(),
            columns: vec!["*".to_string()],
            where_clause: Some(WhereClause {
                condition: Condition::Comparison {
                    left: "name".to_string(),
                    operator: ComparisonOperator::Equal,
                    right: SqlValue::Text("John".to_string()),
                },
            }),
            order_by: None,
            limit: Some(10),
        };

        let plan = planner.plan_select(select).unwrap();

        match plan {
            ExecutionPlan::TableScan {
                table,
                limit,
                early_termination,
                ..
            } => {
                assert_eq!(table, "users");
                assert_eq!(limit, Some(10));
                assert!(early_termination);
            }
            _ => panic!("Expected TableScan plan"),
        }
    }
}
